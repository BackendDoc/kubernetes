# 集群环境准备

在进行集群学习之前，我们先准备虚拟机环境，我们这次使用 `vagran` 来管理虚拟机，如果你电脑上还没有 vagrant 的环境，可以参考这篇文章[https://blog.jkdev.cn/index.php/archives/335/](https://blog.jkdev.cn/index.php/archives/335/)


## 1. 启动虚拟机 

在一个工作目录中创建 `Vagrantfile` 文件，添加以下内容

```ruby
Vagrant.configure("2") do |config|
  config.vm.box = "centos/7"
  # kb11
  config.vm.define "kb11" do |kb11|
    kb11.vm.network "private_network", ip: "10.4.7.11"
    kb11.vm.hostname = "kb11"
    # 指定核心数和内存
    config.vm.provider "virtualbox" do |v|
      v.memory = 2048
      v.cpus = 2
    end
  end
  # kb12
  config.vm.define "kb12" do |kb12|
    kb12.vm.network "private_network", ip: "10.4.7.12"
    kb12.vm.hostname = "kb12"
    # 指定核心数和内存
    config.vm.provider "virtualbox" do |v|
      v.memory = 2048
      v.cpus = 2
    end
  end
  # kb21
  config.vm.define "kb21" do |kb21|
    kb21.vm.network "private_network", ip: "10.4.7.21"
    kb21.vm.hostname = "kb21"
    # 指定核心数和内存
    config.vm.provider "virtualbox" do |v|
      v.memory = 2048
      v.cpus = 2
    end
  end
  # kb22
  config.vm.define "kb22" do |kb22|
    kb22.vm.network "private_network", ip: "10.4.7.22"
    kb22.vm.hostname = "kb22"
    # 指定核心数和内存
    config.vm.provider "virtualbox" do |v|
      v.memory = 2048
      v.cpus = 2
    end
  end
  # kb200
  config.vm.define "kb200" do |kb200|
    kb200.vm.network "private_network", ip: "10.4.7.200"
    kb200.vm.hostname = "kb200"
    # 指定核心数和内存
    config.vm.provider "virtualbox" do |v|
      v.memory = 2048
      v.cpus = 2
    end
  end
end
```


以上的配置文件，我们指定了 `centos 7` 作为所有虚拟机的基础镜像，并且分别定义了 5 台虚拟机，使用以下命令启动虚拟机

```shell
# 启动虚拟机
vagran up
```

启动虚拟机之后进入虚拟机，修改 root 用户密码，在接下来的集群搭建操作中，我们都将在 root 用户下进行。以 kb11 为例，操作指令如下：

```shell
# 进入 kb11 虚拟机
vagrant ssh kb11
# 修改root账号密码
sudo passwd root
# 切换到 root 用户
su
```

我们使用 `vim /etc/sysconfig/network-scripts/ifcfg-eth1` 命令修改一下每一台主机的网卡配置文件，在所有配置参数的末尾添加`GATEWAY`和`DNS1`配置，DNS改为和网关一样。

```shell
# The contents below are automatically generated by Vagrant. Do not modify.
NM_CONTROLLED=yes
BOOTPROTO=none
ONBOOT=yes
IPADDR=10.4.7.11
NETMASK=255.255.255.0
DEVICE=eth1
PEERDNS=no
GATEWAY=10.4.7.254
DNS1=10.4.7.254
#VAGRANT-END
```


安装完成之后，确保每台主机之间能相互连通，虚拟环境准备就完成了！


## 2. 初始化

初始化工作在所有的主机上执行


关闭selinx防火墙
```shell
setenforce 0
systemctl stop firewalld
```

安装epel源

```shell
yum install -y epel-release
```


安装常用的工具
```shell
yum install -y wget net-tools telnet tree nmap sysstat lrzaz doc2unix bind-utils
```

## 3. 初始化域名解析服务器

我们把 `kb11` 这台主机作为域名服务器。接下来进行初始化操作。

安装bind9软件

```shell
yum install -y bind
```

安装好bind之后，修改bind的配置文件`/etc/named.conf`，修改的配置参数如下
```shell
# 修改服务的IP
listen-on port 53 { 10.4.7.11; };
# 允许任意主机使用解析服务
allow-query     { any; };
# 添加 forwarders 键， 值网关地址
forwarders      { 10.4.7.254; };
# 使用递归的方式
recursion yes;
#关闭sec
dnssec-enable no;
dnssec-validation no;
```


修改区域配置文件 `/etc/named.rfc1912.zones`，覆盖默认内容如下：
```shell
zone "host.com" IN {
	type master;
	file "host.com.zone";
	allow-update { 10.4.7.1; };
};

zone "od.com" IN {
	type master;
	file "od.com.zone";
	allow-update { 10.4.7.1; };
};
```

编辑区域数据文件`/var/named/host.com.zone`，改为如下内容

```shell
$ORIGIN host.com.
$TTL 600 ; 10 minutes
@ IN SOA dns.host.com. dnsadmin.host.com. (
    2022012001 ; serial
    10800      ; refresh (3 hours)
    900        ; retry (15 minutes)
    604800     ; expire (1 week)
    86400      ; minium (1 day)
    )
    NS dns.host.com.

$TTL 60    ;   1 minute
dns           A      10.4.7.11
HDSS7-11      A      10.4.7.11
HDSS7-12      A      10.4.7.12
HDSS7-21      A      10.4.7.21
HDSS7-22      A      10.4.7.22
HDSS7-200     A      10.4.7.200
```


编辑区域数据文件`/var/named/od.com.zone`，改为如下内容

```shell
$ORIGIN od.com.
$TTL 600 ; 10 minutes
@ IN SOA dns.od.com. dnsadmin.od.com. (
    2022012002 ; serial
    10800      ; refresh (3 hours)
    900        ; retry (15 minutes)
    604800     ; expire (1 week)
    86400      ; minium (1 day)
    ) 
    NS dns.od.com.

$TTL 60    ;   1 minute
dns    A   10.4.7.11
```

启动dns服务

```shell
# 启动dns 服务
systemctl start named
# 将dns 服务设置为开机自启
systemctl enable named
```



验证dns是否正常

```shell
# 查询53端口服务
netstat -luntp | grep 53
```

可以看到53端口服务正常运行，如下图所示

![./img/named.png](./img/02-01.png)


查看dns是否正常解析
```shell
dig -t A hdss7-21.host.com @10.4.7.11 +short
```

如果看到正常返回IP地址，则代表解析正常。


这时候，我们需要把我们的`kb1`主机的DNS改为`我们自建的DNS服务`，修改 `/etc/sysconfig/network-scripts/ifcfg-eth1` 文件为的 DNS1 配置，如下

```shell
DNS1=10.4.7.11
```

再重启服务
```shell
systemctl restart network
```


## 4. 修改所有的主机的域名解析服务器

重启网络服务之后，在客户端配置`/etc/resolv.conf`文件，改为如下内容

```shell
# 查询主机域
search host.com
# 解析服务器
nameserver 10.4.7.11
```


我们再使用如下指令检测是否解析正常
```shell
ping hdss7-21.host.com
# 因为设置了 search ，也可以直接ping 短域名
ping hdss7-21
```

如果返回如下图内容，这代表dns正常解析

![./img/02-02.png](./img/02-02.png)


我们在 `/etc/resolv.conf` 文件中修改只是让主机临时生效，如果重启之后，系统将会根据网卡配置来指定对应的 域名解析服务器，所以永久生效的方式应当是 修改网卡 配置中的DNS域名。


> 注意：`/etc/resolv.conf` 设置域名解析时，主机域名可以使用 `search` 标注查询的主机域，但注意 业务域名不要使用这个配置








